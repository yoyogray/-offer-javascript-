<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title></title>
    
</head>
<body>
    <script>
       

        

           斐波那契
        function f(n){
            if(n == 0||n==1){
                return n
            }else{
                return (f(n-1)+f(n-2))
            }
        }
        f(10)

        
            扑克

            function isContinuous(numbers){
                var kings = 0,
                    len = numbers.length,
                    flag = true;
                
                for(var i = 0;i<len;i++){
                    if(numbers[i] === 0){
                        numbers.splice(i,1);
                        kings++
                        // console.log(numbers + " " + kings)                        
                    }
                }
                numbers.sort(function(a,b){
                    return a - b
                })//升序
                console.log(numbers);

                for(var j = 0;j<len;j++){
                    // flag = (numbers[j+1] - numbers[j]>kings+1)?false:true 
                    if(numbers[j+1] - numbers[j] > kings+1){
                        flag = false;
                    }
                }
                
                return flag;
                
            }

            console.log(isContinuous([10,11,14,0,0]))


            



    function isok(numbers){
        var len = numbers.length,
            kings = 0,
            flag = true;
        for (var i = 0; i < len; i++) {
            if(numbers[i] === 0){
                numbers.splice(i,1)
                i--;
                kings++
            }
        }
        numbers.sort(function(a,b){
            return a - b;
        })
        console.log(numbers);
        for(var i = 0;i<len;i++){
            if((numbers[i+1] - numbers[i]) > (kings + 1)){
                flag = false;
            }
        }
        console.log(flag)
    }
    isok([7,8,0,0,1])

    递归求树的深度、

 
    
    

    求二叉树的深度
    function deep(root){
        if(root == null){
            return 0
        };
        var left = deep(root.left);
        var right = deep(root.right);
        return (left > right)?left+1:right+1
    }



    利用求二叉树深度来判断是否为平衡二叉树

    思路：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个
    子树都是一棵平衡二叉树。遍历左子树和右子树的深度，然后比较二者差值


    function deep(root){
        if(root == null)return 0;
        var left = deep(root.left);
        var right = deep(root.right);
        ruturn (left>right)?left + 1:right+1;
    }


    function isbalance(root){
        var left = deep(root.left);
        var right = deep(root.right);
        if((left - right) > 1 || (left - right) < -1){
            return false;
        }else{
            return true;
        }
        return isbalance(root.left) && isbalance(root.right)
    }

    数组去重
    
    


        Array.prototype.uniq = function(){
            var emp = [];
            var obj = {};
            var len = this.length;
            for(var i = 0;i<len;i++){
                if(!obj[this[i]]){
                    emp.push(this[i]);
                    obj[this[i]] = 1;
                }
            }            
            console.log(emp)
            return emp
        }

        var a = [8,1,1,2,3,23,1,3,1,31,31,3,13,3];
        a.uniq();

        function findNum(arr){
            var a = arr;
            var b = a.uniq();
            var len = b.length;
            var empty = [];
            var k = 0 ;
            for(var i = 0;i<len;i++){
                for(var j = 0;j<len;j++){
                    if(a[j] == b[i]){
                        k++
                    }
                }
                if(k === 1){
                    arr.push(b[i]);
                }
                k = 0;
            }
            return empty;
        }

        findNum([1,1,3,23,2,32,1,1,3,213,2,23,2])
        
        


            var a = [1,1,1,12,2,3];
            function find(arr){
                var emp = [];
                var len = arr.length;
                for(var i = 0;i<len;i++){
                    if(arr.indexOf(arr[i]) == -1){
                        emp.push(arr[i])
                    }
                }
                return emp
            }

            // console.log(a.indexOf(a[1]))

            console.log(find(a));
            


            最小公约数
            function gcd(a,b){
                if(b == 0){
                    return a
                }
                var r = parseInt(a % b);
                return gcd(b,r)
            }
            console.log(gcd(8,3))
              
            

            function f(n){
                if(n == 1||n == 2){
                    return 1
                }
                return f(n - 1) + f(n - 2)
            }

            console.log(f(10))


            
            
            


            



        
        
    </script>

</body>
</html>